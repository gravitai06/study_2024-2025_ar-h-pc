---
title: "Отчет по лабораторной работе №8"
subtitle: "Дисциплина: архитектура компьютера"
author: "Царёв Максим Александрович"

## Generic options
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt

## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
    - spelling=modern
    - babelshorthands=true
polyglossia-otherlangs:
  name: english

## I18n babel
babel-lang: russian
babel-otherlangs: english

## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: "Ligatures=Common,Ligatures=TeX,Scale=0.94"
romanfontoptions: "Ligatures=Common,Ligatures=TeX,Scale=0.94"
sansfontoptions: "Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94"
monofontoptions: "Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9"
mathfontoptions:

## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric

## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"

## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where they are in the text
  - \floatplacement{figure}{H} # keep figures where they are in the text
---

# Цель работы

Приобретение навыков написания программ с использованием циклов и обработкой
аргументов командной строки.

# Задание

1. Программа вывода значений регистра ecx
2. Программа выводящая на экран аргументы командной строки
3. Программа вычисления суммы аргументов командной строки
4. Выполнение заданий для самостоятельной работы

# Теоретическое введение

Стек — это структура данных, организованная по принципу LIFO («Last In — First Out»
или «последним пришёл — первым ушёл»). Стек является частью архитектуры процессора и
реализован на аппаратном уровне. Для работы со стеком в процессоре есть специальные
регистры (ss, bp, sp) и команды.
Основной функцией стека является функция сохранения адресов возврата и передачи
аргументов при вызове процедур. Кроме того, в нём выделяется память для локальных
переменных и могут временно храниться значения регистров.
Стек имеет вершину, адрес последнего добавленного элемента, который хранится в ре-
гистре esp (указатель стека). Противоположный конец стека называется дном. Значение,
помещённое в стек последним, извлекается первым. При помещении значения в стек указа-
тель стека уменьшается, а при извлечении — увеличивается.
Для стека существует две основные операции:
• добавление элемента в вершину стека (push);
• извлечение элемента из вершины стека (pop).
Добавление элемента в стек.
Команда push размещает значение в стеке, т.е. помещает значение в ячейку памяти, на
которую указывает регистр esp, после этого значение регистра esp увеличивается на 4.
Данная команда имеет один операнд — значение, которое необходимо поместить в стек.
Примеры:

![Организация стека в процессоре](image/1.jpg){ #fig:001 width=70% }

`push -10` ;       Поместить -10 в стек

`push ebx` ;       Поместить значение регистра ebx в стек

`push [buf]` ;     Поместить значение переменной buf в стек

`push word [ax]` ; Поместить в стек слово по адресу в ax

Существует ещё две команды для добавления значений в стек. Это команда pusha, которая
помещает в стек содержимое всех регистров общего назначения в следующем порядке: ах,
сх, dx, bх, sp, bp, si, di. А также команда pushf, которая служит для перемещения в стек
содержимого регистра флагов. Обе эти команды не имеют операндов.

Извлечение элемента из стека.
Команда pop извлекает значение из стека, т.е. извлекает значение из ячейки памяти, на
которую указывает регистр esp, после этого уменьшает значение регистра esp на 4. У этой
команды также один операнд, который может быть регистром или переменной в памяти.
Нужно помнить, что извлечённый из стека элемент не стирается из памяти и остаётся как
“мусор”, который будет перезаписан при записи нового значения в стек.
Примеры:

```pop eax ;         Поместить значение из стека в регистр eax```

```pop [buf] ;       Поместить значение из стека в buf```

```pop word[si] ;    Поместить значение из стека в слово по адресу в si
```
Аналогично команде записи в стек существует команда popa, которая восстанавливает
из стека все регистры общего назначения, и команда popf для перемещения значений из
вершины стека в регистр флагов.

Инструкции организации циклов
Для организации циклов существуют специальные инструкции. Для всех инструкций
максимальное количество проходов задаётся в регистре ecx. Наиболее простой является ин-
струкция loop. Она позволяет организовать безусловный цикл, типичная структура которого
имеет следующий вид:

mov ecx, 100       ; Количество проходов

NextStep:

; тело цикла

; ...  

loop NextStep       ; Повторить `ecx` раз от метки NextStep

Иструкция loop выполняется в два этапа. Сначала из регистра ecx вычитается единица и
его значение сравнивается с нулём. Если регистр не равен нулю, то выполняется переход к
указанной метке. Иначе переход не выполняется и управление передаётся команде, которая
следует сразу после команды loop.

# Выполнение лабораторной работы

Создаю каталог lab8, перехожу в него,создаю файл lab8-1.asm. Я скопировал внешний файл в созданный ката-
лог, ввёл текст программы.

![](image/2.jpg){ #fig:002 width=70% }

Проверил программу на корректную работу,программа работает некорректно,выводит бесконечное колличество значений

![](image/3.jpg){ #fig:003 width=70% }

Изменяю текст программы добавив изменение значения регистра ecx в цикле

![](image/4.jpg){ #fig:004 width=70% }

запускаю программу,теперь она работает верно

![](image/5.jpg){ #fig:005 width=70% }

В данной программе регистр ecx принимает значения от N−1N−1 до 00, где NN — это значение, введённое пользователем с клавиатуры.
ecx устанавливается равным введённому значению N, т.е. ecx = N.
В каждом проходе цикла ecx уменьшается на 1 с помощью sub ecx,1. Команда loop label проверяет значение ecx. Если ecx не равно нулю, то выполняется следующий проход цикла. Когда ecx достигает нуля, выполнение цикла завершается.
Нет, число проходов цикла  не соответствует значению N, введённому с клавиатуры, так как команда loop повторяет цикл ровно N/2 раз, начиная с N и заканчивая 0.
Вношу изменения в текст программы добавив команды push
и pop для сохранения значения счетчика цикла loop

![](image/6.jpg){ #fig:006 width=70% }

Теперь программа работает верно, делает ровно N проходов

![](image/7.jpg){ #fig:007 width=70% }

## Обработка аргументов командной строки

Создаю файл lab8-2.asm и ввожу в него текст программы из листинга 8.2

![](image/8.jpg){ #fig:008 width=70% }

Создал исполняемый файл и запустил его, указав аргументы,программой был обработан каждый аргумент

![](image/9.jpg){ #fig:009 width=70% }

Создал файл lab8-3.asm и ввожу в него текст программы из листинга 8.3


![](image/10.jpg){ #fig:010 width=70% }

Создал исполняемый файл и запустил его, указав аргументы,программой был обработан каждый аргумент

![](image/11.jpg){ #fig:011 width=70% }

Изменил текст программы из листинга 8.3 для вычисления произведения аргументов
командной строки

![](image/12.jpg){ #fig:012 width=70% }

Программа работает верно

## Выполнение заданий для самостоятельной работы

Создаю файл lab8-4.asm,пишу программу соответственно своему варианту - 20

![](image/13.jpg){ #fig:013 width=70% }

![](image/14.jpg){ #fig:014 width=70% }

Программа работает  корректно

# Выводы

Я приобрел навыки написания программ с использованием циклов и обработкой
аргументов командной строки.


